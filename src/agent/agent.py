# Copyright (c) 2025 Bytedance Ltd. and/or its affiliates
# SPDX-License-Identifier: MIT

from dataclasses import dataclass, field
from enum import Enum
from types import CoroutineType
from typing import Any, Callable, Literal, Union

from .schema import ErrorMarker, ToolCall, ToolCallResult

DEFAULT_MAX_STEPS = 50
DEFAULT_MAX_ERROR_COUNT = 3


@dataclass
class Agent:
    """An agent is an AI model configured with instructions, tools, and more."""

    name: str
    """The name of the agent."""

    instructions: str | None = None
    """The instructions for the agent. Will be used as the "system prompt" when this agent is
    invoked. Describes what the agent should do, and how it responds."""

    tools: dict[str, Callable[..., CoroutineType]] = field(default_factory=dict)
    """A list of tools that the agent can use."""

    tools_desc: list[dict] = field(default_factory=list)
    """A list of tools description that the agent can use."""

    output_type: type[Any] | None = None
    """The type of the output object. If not provided, the output will be `str`."""

    model_config_name: str = "doubao-1.6"

    def get_tool_by_name(self, tool_name: str) -> Callable[..., CoroutineType] | None:
        """Return the tool by name."""
        return self.tools.get(tool_name)


class StepStatus(str, Enum):
    """The state of the end of a step"""

    USER = "USER"
    FINISHED = "FINISHED"
    CONTINUE = "CONTINUE"
    ERROR = "ERROR"


@dataclass
class ActionStepError:
    """The error marker of the action step.

    The most important purpose of this class is to provide a way to mark the error during action step.
    It can be used to implement the retry mechanism and `continue` method of `Runner`.
    """

    message: str
    source: Literal["llm"] = "llm"


@dataclass
class ActionStep:
    """An action step during the execution of an agent."""

    step_status: StepStatus = StepStatus.CONTINUE
    """The status of the step."""

    content: str | None = None
    """The completion content of the step."""

    reasoning_details: object | None = None

    reasoning_content: str | None = None
    """The reasoning content of the step, maybe generated by the reasoning models."""

    signature: str | None = None
    """The signature of the step, maybe generated by the `claude-thinking` models."""

    tool_calls: list[ToolCall] = field(default_factory=list)
    """The tool call of the step."""

    tool_call_results: list[ToolCallResult] = field(default_factory=list)
    """The tool call result of the step."""

    error_marker: ErrorMarker | None = None
    """When an error occurs during action step, the error marker will be set."""

    usage: dict | None = None


@dataclass
class UserInputStep:
    """An user input step during the execution of an agent."""

    user_input: str
    """The user input of the step."""

    step_status: StepStatus = StepStatus.USER
    """The status of the step, note this should not be modified."""


StepType = Union[ActionStep, UserInputStep]


@dataclass
class MemoryTurn:
    """A turn in the memory of an agent, contains one or more steps."""

    steps: list[StepType] = field(default_factory=list)
    """The storage steps in the memory turn."""

    @property
    def step_number(self):
        """Return the action step number of the memory turn."""
        return sum(1 for step in self.steps if isinstance(step, ActionStep))

    def is_finished(self) -> bool:
        """Return whether the memory turn is finished."""
        if len(self.steps) == 0:
            return False
        last_step = self.steps[-1]
        return last_step.step_status == StepStatus.FINISHED


@dataclass
class MemoryAgent:
    """Storage the full memory during agent execution."""

    system_instructions: str | None = None
    """The system instructions of the agent."""

    turns: list[MemoryTurn] = field(default_factory=list)
    """The turns in the memory."""

    @property
    def _need_new_turn(self) -> bool:
        if len(self.turns) == 0:
            return True
        last_turn = self.turns[-1]
        return last_turn.is_finished()

    def _add_new_turn(self):
        turn = MemoryTurn()
        self.turns.append(turn)

    def _last_turn(self) -> MemoryTurn:
        """Return the reference of the last turn"""
        return self.turns[-1]

    def insert_user_input(self, user_input: str):
        """Create a new turn and insert a user input step into the last turn.

        Args:
            user_input (str): The user input of this turn.

        Returns:
            MemoryTurn: The reference of the last turn.
        """
        assert self._need_new_turn, "Failed because need_new_turn is False"

        self._add_new_turn()
        last_turn = self._last_turn()
        last_turn.steps.append(UserInputStep(user_input=user_input))
        return last_turn

    def insert_action_step(self, action_step: ActionStep):
        """Insert an action step into the last turn.
        Args:
            action_step (ActionStep): The action step to insert.
            MemoryTurn: The reference of the last turn.
        """
        assert not self._need_new_turn, "Failed because need_new_turn is True"
        last_turn = self._last_turn()
        last_turn.steps.append(action_step)
        return last_turn

    def to_message(
        self, is_claude_thinking: bool = False, default_system_prompt_insert: str = ""
    ) -> list[dict]:
        """Convert the memory into messages for model.

        Reference of format: https://platform.openai.com/docs/guides/function-calling?api-mode=chat
        """
        messages = []

        def maybe_insert_reasoning_fields(m: dict, step: ActionStep) -> None:
            if step.reasoning_details is not None:
                m["reasoning_details"] = step.reasoning_details
            elif step.reasoning_content:
                m["reasoning_content"] = step.reasoning_content

        if self.system_instructions:
            system_prompt = self.system_instructions
            if default_system_prompt_insert:
                system_prompt = default_system_prompt_insert + "\n" + system_prompt

            messages.append(
                {
                    "role": "system",
                    "content": system_prompt,
                }
            )
        for turn in self.turns:
            for step in turn.steps:
                if isinstance(step, UserInputStep):
                    messages.append(
                        {
                            "role": "user",
                            "content": step.user_input,
                        }
                    )
                elif isinstance(step, ActionStep):
                    if step.error_marker:
                        continue

                    if step.tool_calls:
                        assert step.tool_call_results and len(
                            step.tool_call_results
                        ) == len(step.tool_calls)

                        m_tc = {
                            "role": "assistant",
                            "content": step.content,
                            "tool_calls": [],
                        }
                        maybe_insert_reasoning_fields(m_tc, step)
                        for tc in step.tool_calls:
                            m_tc["tool_calls"].append(
                                {
                                    "id": tc.tool_call_id,
                                    "type": "function",
                                    "function": {
                                        "name": tc.tool_name,
                                        "arguments": tc.arguments,
                                    },
                                }
                            )
                        messages.append(m_tc)

                        for tcr in step.tool_call_results:
                            m_tcr = {
                                "role": "tool",
                                "content": tcr.get_content_or_error(),
                                "tool_call_id": tcr.tool_call_id,
                            }
                            messages.append(m_tcr)

                    else:
                        m = {"role": "assistant", "content": step.content}
                        maybe_insert_reasoning_fields(m, step)
                        messages.append(m)
        return messages
